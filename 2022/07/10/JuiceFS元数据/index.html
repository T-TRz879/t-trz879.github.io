<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="JuiceFS元数据, T_TBlog">
    <meta name="description" content="JuiceFS目前使用三种方式存储元数据，分别是Redis、TIKV和SQL。接下来分别介绍Juicefs存储元数据的三种方式。
打开文件缓存JuiceFS提供在打开文件/文件夹时将属性和Slice进行缓存，方便在下一次访问时，直接获取属性">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    

    <title>JuiceFS元数据 | T_TBlog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">T_TBlog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">T_TBlog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/8.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">JuiceFS元数据</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/metadata%E5%AD%98%E5%82%A8/">
                                <span class="chip bg-color">metadata存储</span>
                            </a>
                        
                            <a href="/tags/Redis/">
                                <span class="chip bg-color">Redis</span>
                            </a>
                        
                            <a href="/tags/Tikv/">
                                <span class="chip bg-color">Tikv</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/JuiceFS/" class="post-category">
                                JuiceFS
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-07-10
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2022-07-10
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    4.4k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    22 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>JuiceFS目前使用三种方式存储元数据，分别是Redis、TIKV和SQL。接下来分别介绍Juicefs存储元数据的三种方式。</p>
<h2 id="打开文件缓存"><a href="#打开文件缓存" class="headerlink" title="打开文件缓存"></a>打开文件缓存</h2><p>JuiceFS提供在打开文件/文件夹时将属性和Slice进行缓存，方便在下一次访问时，直接获取属性和Slice。</p>
<p>在挂载时加入以下参数就可以开启这个功能</p>
<pre class=" language-lang-shell"><code class="language-lang-shell"># value是用户自己指定的，默认为0，单位是秒
--open-cache value
</code></pre>
<h3 id="打开文件缓存相关结构体和方法"><a href="#打开文件缓存相关结构体和方法" class="headerlink" title="打开文件缓存相关结构体和方法"></a>打开文件缓存相关结构体和方法</h3><h4 id="openFile"><a href="#openFile" class="headerlink" title="openFile"></a>openFile</h4><pre class=" language-lang-go"><code class="language-lang-go">type openFile struct {
    sync.RWMutex
    attr      Attr               //属性
    refs      int                //引用次数
    lastCheck time.Time          //上一次check时间
    chunks    map[uint32][]Slice //    Read的Slice
}
</code></pre>
<h4 id="openfiles"><a href="#openfiles" class="headerlink" title="openfiles"></a>openfiles</h4><p>baseMeta会持有一个openfiles</p>
<pre class=" language-lang-go"><code class="language-lang-go">type openfiles struct {
    sync.Mutex
    expire time.Duration     //    过期时间
    files  map[Ino]*openFile //key-Ino value-openFile的map数组
}
</code></pre>
<h4 id="openfiles-Update"><a href="#openfiles-Update" class="headerlink" title="openfiles.Update"></a>openfiles.Update</h4><p>更新ino的属性</p>
<pre class=" language-lang-go"><code class="language-lang-go">func (o *openfiles) Update(ino Ino, attr *Attr) bool {
    if attr == nil {
        panic("attr is nil")
    }
    o.Lock()
    defer o.Unlock()
    of, ok := o.files[ino]
    if ok {
        if attr.Mtime != of.attr.Mtime || attr.Mtimensec != of.attr.Mtimensec {
            of.chunks = make(map[uint32][]Slice)
        } else {
            attr.KeepCache = of.attr.KeepCache
        }
        of.attr = *attr
        of.lastCheck = time.Now()
        return true
    }
    return false
}
</code></pre>
<h2 id="Redis存储"><a href="#Redis存储" class="headerlink" title="Redis存储"></a>Redis存储</h2><h3 id="存储格式"><a href="#存储格式" class="headerlink" title="存储格式"></a>存储格式</h3><ul>
<li>Node：以[i + inode]的格式存储文件的类别、权限、拥有者、创建时间、修改时间、长度等信息</li>
<li>Dir：以[d + inode]的格式存储文件夹中的文件名称和inode对应关系</li>
<li>File：以[c + inode_indx]的格式存储文件的Block信息，用于将元数据和Block绑定</li>
</ul>
<pre class=" language-lang-yaml"><code class="language-lang-yaml">    Node: i$inode -> Attribute{type,mode,uid,gid,atime,mtime,ctime,nlink,length,rdev}
    Dir:   d$inode -> {name -> {inode,type}}
    File:  c$inode_$indx -> [Slice{pos,id,length,off,len}]
    Symlink: s$inode -> target
    Xattr: x$inode -> {name -> value}
    Flock: lockf$inode -> { $sid_$owner -> ltype }
    POSIX lock: lockp$inode -> { $sid_$owner -> Plock(pid,ltype,start,end) }
    Sessions: sessions -> [ $sid -> heartbeat ]
    sustained: session$sid -> [$inode]
    locked: locked$sid -> { lockf$inode or lockp$inode }

    Removed files: delfiles -> [$inode:$length -> seconds]
    Slices refs: k$chunkid_$size -> refcount
</code></pre>
<h3 id="生成Key"><a href="#生成Key" class="headerlink" title="生成Key"></a>生成Key</h3><pre class=" language-lang-go"><code class="language-lang-go">func (r *redisMeta) sustained(sid uint64) string {
    return "session" + strconv.FormatUint(sid, 10)
}

func (r *redisMeta) lockedKey(sid uint64) string {
    return "locked" + strconv.FormatUint(sid, 10)
}

func (r *redisMeta) symKey(inode Ino) string {
    return "s" + inode.String()
}
// 文件的属性信息key
func (r *redisMeta) inodeKey(inode Ino) string {
    return "i" + inode.String()
}
//文件夹下的文件信息key
func (r *redisMeta) entryKey(parent Ino) string {
    return "d" + parent.String()
}
//文件的Block信息key
func (r *redisMeta) chunkKey(inode Ino, indx uint32) string {
    return "c" + inode.String() + "_" + strconv.FormatInt(int64(indx), 10)
}

func (r *redisMeta) sliceKey(chunkid uint64, size uint32) string {
    return "k" + strconv.FormatUint(chunkid, 10) + "_" + strconv.FormatUint(uint64(size), 10)
}

func (r *redisMeta) xattrKey(inode Ino) string {
    return "x" + inode.String()
}

func (r *redisMeta) flockKey(inode Ino) string {
    return "lockf" + inode.String()
}

func (r *redisMeta) ownerKey(owner uint64) string {
    return fmt.Sprintf("%d_%016X", r.sid, owner)
}

func (r *redisMeta) plockKey(inode Ino) string {
    return "lockp" + inode.String()
}
</code></pre>
<h3 id="Juicefs利用Redis保证事务的一致性"><a href="#Juicefs利用Redis保证事务的一致性" class="headerlink" title="Juicefs利用Redis保证事务的一致性"></a>Juicefs利用Redis保证事务的一致性</h3><h3 id="SetAttr"><a href="#SetAttr" class="headerlink" title="SetAttr"></a>SetAttr</h3><h4 id="redisMeta-SetAttr"><a href="#redisMeta-SetAttr" class="headerlink" title="redisMeta.SetAttr"></a>redisMeta.SetAttr</h4><ul>
<li>取出inode的atrr属性并且解析出来</li>
<li>changed用来记录传入的attr和解析出来的cur参数是否一样</li>
<li>如果全部一样则不需要将attr写入元数据引擎中，反之则需要写入</li>
</ul>
<pre class=" language-lang-go"><code class="language-lang-go">func (r *redisMeta) SetAttr(ctx Context, inode Ino, set uint16, sugidclearmode uint8, attr *Attr) syscall.Errno {
    defer timeit(time.Now())
    logger.Infof("redisMeta SetAttr inode:%d set:%d attr:%v", inode, set, attr)
    inode = r.checkRoot(inode)
    defer func() { r.of.InvalidateChunk(inode, 0xFFFFFFFE) }()
    return errno(r.txn(ctx, func(tx *redis.Tx) error {
        var cur Attr
        // 获取inode的属性
        a, err := tx.Get(ctx, r.inodeKey(inode)).Bytes()
        if err != nil {
            return err
        }
        // 解析出inode的属性
        r.parseAttr(a, &cur)
        if (set&(SetAttrUID|SetAttrGID)) != 0 && (set&SetAttrMode) != 0 {
            attr.Mode |= (cur.Mode & 06000)
        }
        var changed bool
        if (cur.Mode&06000) != 0 && (set&(SetAttrUID|SetAttrGID)) != 0 {
            clearSUGID(ctx, &cur, attr)
            changed = true
        }
        if set&SetAttrUID != 0 && cur.Uid != attr.Uid {
            cur.Uid = attr.Uid
            changed = true
        }
        if set&SetAttrGID != 0 && cur.Gid != attr.Gid {
            cur.Gid = attr.Gid
            changed = true
        }
        if set&SetAttrMode != 0 {
            if ctx.Uid() != 0 && (attr.Mode&02000) != 0 {
                if ctx.Gid() != cur.Gid {
                    attr.Mode &= 05777
                }
            }
            if attr.Mode != cur.Mode {
                cur.Mode = attr.Mode
                changed = true
            }
        }
        now := time.Now()
        if set&SetAttrAtime != 0 && (cur.Atime != attr.Atime || cur.Atimensec != attr.Atimensec) {
            cur.Atime = attr.Atime
            cur.Atimensec = attr.Atimensec
            changed = true
        }
        if set&SetAttrAtimeNow != 0 {
            cur.Atime = now.Unix()
            cur.Atimensec = uint32(now.Nanosecond())
            changed = true
        }
        if set&SetAttrMtime != 0 && (cur.Mtime != attr.Mtime || cur.Mtimensec != attr.Mtimensec) {
            cur.Mtime = attr.Mtime
            cur.Mtimensec = attr.Mtimensec
            changed = true
        }
        if set&SetAttrMtimeNow != 0 {
            cur.Mtime = now.Unix()
            cur.Mtimensec = uint32(now.Nanosecond())
            changed = true
        }
        // 每次判断attr中的属性是否修改过，未修改则不需要写入元数据引擎
        if !changed {
            *attr = cur
            return nil
        }
        cur.Ctime = now.Unix()
        cur.Ctimensec = uint32(now.Nanosecond())
        _, err = tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {
            pipe.Set(ctx, r.inodeKey(inode), r.marshal(&cur), 0)
            return nil
        })
        if err == nil {
            *attr = cur
        }
        return err
    }, r.inodeKey(inode)))
}
</code></pre>
<h3 id="GetAttr"><a href="#GetAttr" class="headerlink" title="GetAttr"></a>GetAttr</h3><h4 id="baseMeta-GetAttr"><a href="#baseMeta-GetAttr" class="headerlink" title="baseMeta.GetAttr"></a>baseMeta.GetAttr</h4><ul>
<li>校验inode，JuiceFS默认inode=1的是挂载点目录，将inode &lt;= 1的都设置为1，其它的不变</li>
<li>inode为1时，取出文件夹的属性，如果取出失败，则自动填充默认的挂载点文件夹属性</li>
<li>inode不为1时，正常去元数据引擎中获取属性</li>
<li>获取属性时正常，则将获取的属性放入openFile的map中</li>
</ul>
<pre class=" language-lang-go"><code class="language-lang-go">func (m *baseMeta) GetAttr(ctx Context, inode Ino, attr *Attr) syscall.Errno {
    logger.Infof("baseMeta GetAttr inode:%d checkRootInode:%d", inode, m.checkRoot(inode))
    // 校验Inode，避免0的inode
    inode = m.checkRoot(inode)
    if m.conf.OpenCache > 0 && m.of.Check(inode, attr) {
        return 0
    }
    defer timeit(time.Now())
    var err syscall.Errno
    if inode == 1 {
        // 挂载点目录的inode=1,这个去元数据引擎中获取元属性
        logger.Infof("baseMeta GetAttr getInode[1]")
        e := utils.WithTimeout(func() error {
            err = m.en.doGetAttr(ctx, inode, attr)
            return nil
        }, time.Millisecond*300)
        // 如果出错，那么就需要将挂载点目录的attr修改为默认的
        if e != nil || err != 0 {
            err = 0
            attr.Typ = TypeDirectory
            attr.Mode = 0777
            attr.Nlink = 2
            attr.Length = 4 << 10
        }
    } else {
        // 其它的文件/文件夹获取属性
        err = m.en.doGetAttr(ctx, inode, attr)
    }
    // 更新属性(只会保存在以inode为key的map中)
    if err == 0 {
        m.of.Update(inode, attr)
    }
    return err
}
</code></pre>
<h4 id="redisMeta-doGetAttr"><a href="#redisMeta-doGetAttr" class="headerlink" title="redisMeta.doGetAttr"></a>redisMeta.doGetAttr</h4><pre class=" language-lang-go"><code class="language-lang-go">func (r *redisMeta) doGetAttr(ctx Context, inode Ino, attr *Attr) syscall.Errno {
    a, err := r.rdb.Get(ctx, r.inodeKey(inode)).Bytes()
    if err == nil {
        r.parseAttr(a, attr)
    }
    return errno(err)
}
</code></pre>
<h3 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h3><p><strong><em>无法创建文件夹的硬链接。关于Attr.Nlink这个变量来说，在Link和Unlink中只涉及文件的硬链接个数；而在文件夹中Nlink是指当前文件夹中有多少个文件/文件夹；一个文件默认Nlink为1；回收站中的文件无法创建硬链接（务必明白这几个概念）</em></strong></p>
<h4 id="baseMeta-Link"><a href="#baseMeta-Link" class="headerlink" title="baseMeta.Link"></a>baseMeta.Link</h4><ul>
<li>无法创建回收站中文件/文件夹硬链接</li>
<li>无法创建回收站文件夹硬链接</li>
<li>挂载点是只读权限的话无法创建硬链接</li>
<li>校验parentInode</li>
</ul>
<pre class=" language-lang-go"><code class="language-lang-go">func (m *baseMeta) Link(ctx Context, inode, parent Ino, name string, attr *Attr) syscall.Errno {
    logger.Infof("baseMeta Link inode:%d parent:%d name:%s", inode, parent, name)
    // 无法创建回收站中文件的Inode的硬链接
    if isTrash(parent) {
        return syscall.EPERM
    }
    // 无法创建回收站文件夹的Inode硬链接
    if parent == 1 && name == TrashName {
        return syscall.EPERM
    }
    // 当前挂载点只读权限的话就直接返回
    if m.conf.ReadOnly {
        return syscall.EROFS
    }

    defer timeit(time.Now())
    // 校验parentInode
    parent = m.checkRoot(parent)
    defer func() { m.of.InvalidateChunk(inode, 0xFFFFFFFE) }()
    return m.en.doLink(ctx, inode, parent, name, attr)
}
</code></pre>
<h4 id="redisMeta-doLink"><a href="#redisMeta-doLink" class="headerlink" title="redisMeta.doLink"></a>redisMeta.doLink</h4><ul>
<li>获取parent（name父目录）和inode（硬链接源）的属性</li>
<li>如果获取的两个属性有一个为空就返回</li>
<li>解析parent和inode属性</li>
<li>parent属性中Typ不能是文件，inode属性中Typ不能是文件夹</li>
<li>将inode属性中的硬链接个数+1</li>
<li>判断parent文件夹中是否已经存在名称为name的文件，如果存在无法创建</li>
<li>更新硬链接相关的属性<ul>
<li>将硬链接文件和parent的文件夹创建关系</li>
<li>更新parent文件夹属性</li>
<li>添加硬链接文件</li>
</ul>
</li>
</ul>
<pre class=" language-lang-go"><code class="language-lang-go">// parent指硬链接名为name的父目录Inode
// name指创建的硬链接的文件名称
// inode指硬链接源文件
func (r *redisMeta) doLink(ctx Context, inode, parent Ino, name string, attr *Attr) syscall.Errno {
    return errno(r.txn(ctx, func(tx *redis.Tx) error {
        // 同时获取parent和inode的属性
        rs, err := tx.MGet(ctx, r.inodeKey(parent), r.inodeKey(inode)).Result()
        if err != nil {
            return err
        }
        // 只要有一个不存在返回
        if rs[0] == nil || rs[1] == nil {
            return redis.Nil
        }
        // 解析父目录的属性和链接源的属性
        var pattr, iattr Attr
        r.parseAttr([]byte(rs[0].(string)), &pattr)
        // 父目录的文件类型必须是dir
        if pattr.Typ != TypeDirectory {
            return syscall.ENOTDIR
        }
        now := time.Now()
        pattr.Mtime = now.Unix()
        pattr.Mtimensec = uint32(now.Nanosecond())
        pattr.Ctime = now.Unix()
        pattr.Ctimensec = uint32(now.Nanosecond())
        r.parseAttr([]byte(rs[1].(string)), &iattr)
        // 链接源的属性必须是文件（不允许创建文件夹的硬链接）
        if iattr.Typ == TypeDirectory {
            return syscall.EPERM
        }
        iattr.Ctime = now.Unix()
        iattr.Ctimensec = uint32(now.Nanosecond())
        // 硬链接个数加1
        iattr.Nlink++
        // 判断parent文件夹中是否已经存在一个name的文件，如果name名称的文件存在，则无法创建硬链接
        err = tx.HGet(ctx, r.entryKey(parent), name).Err()
        if err != nil && err != redis.Nil {
            return err
        } else if err == nil {
            return syscall.EEXIST
        } else if err == redis.Nil && r.conf.CaseInsensi && r.resolveCase(ctx, parent, name) != nil {
            return syscall.EEXIST
        }

        _, err = tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {
            // 将硬链接文件添加入parent的文件夹中 key-d&parent
            logger.Infof("link r.entryKey:%s name:%s", r.entryKey(parent), name)
            pipe.HSet(ctx, r.entryKey(parent), name, r.packEntry(iattr.Typ, inode))
            // 更新parent的属性
            logger.Infof("link r.inodeKey:%s p.marshal:%v", r.inodeKey(parent), pattr)
            pipe.Set(ctx, r.inodeKey(parent), r.marshal(&pattr), 0)
            // 添加硬链接文件
            logger.Infof("link r.entryKey:%s i.marshal:%v", r.inodeKey(inode), iattr)
            pipe.Set(ctx, r.inodeKey(inode), r.marshal(&iattr), 0)
            return nil
        })
        if err == nil && attr != nil {
            *attr = iattr
        }
        return err
    }, r.inodeKey(inode), r.entryKey(parent), r.inodeKey(parent)))
}
</code></pre>
<h3 id="Unlink"><a href="#Unlink" class="headerlink" title="Unlink"></a>Unlink</h3><h4 id="baseMata-Unlink"><a href="#baseMata-Unlink" class="headerlink" title="baseMata.Unlink"></a>baseMata.Unlink</h4><ul>
<li>无法删除回收站目录（<strong>.trash目录</strong>）</li>
<li>无法删除回收站中以日期时间格式的文件夹</li>
</ul>
<p><img src="/2022/07/10/JuiceFS%E5%85%83%E6%95%B0%E6%8D%AE/trash目录中文件夹格式.jpg" alt="trash目录中文件夹格式.jpg" style="zoom:90%;"></p>
<ul>
<li>当前挂载点是只读的，没有删除操作权限</li>
</ul>
<pre class=" language-lang-go"><code class="language-lang-go">func (m *baseMeta) Unlink(ctx Context, parent Ino, name string) syscall.Errno {
    // 无法删除回收站目录，且用户不是mount的用户时，无法删除回收站中的内容
    if parent == 1 && name == TrashName || isTrash(parent) && ctx.Uid() != 0 {
        return syscall.EPERM
    }
    // 当挂载点是只读时，无法进行删除操作
    if m.conf.ReadOnly {
        return syscall.EROFS
    }

    defer timeit(time.Now())
    return m.en.doUnlink(ctx, m.checkRoot(parent), name)
}
</code></pre>
<h4 id="redisMeta-doUnlink"><a href="#redisMeta-doUnlink" class="headerlink" title="redisMeta.doUnlink"></a>redisMeta.doUnlink</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">变量</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">parnet</td>
<td style="text-align:center">unlink文件父节点的Inode</td>
</tr>
<tr>
<td style="text-align:center">name</td>
<td style="text-align:center">需要unlink的文件名称</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">name的inode</td>
</tr>
<tr>
<td style="text-align:center">buf</td>
<td style="text-align:center">byte数组其中存放的是name的Inode和属性</td>
</tr>
<tr>
<td style="text-align:center">keys</td>
<td style="text-align:center">unlink时所有相关的key，用来保证Redis在unlink时的事务一致性</td>
</tr>
<tr>
<td style="text-align:center">trash</td>
<td style="text-align:center">trash=0，<strong>没有配置回收站</strong>或<strong>parnet是属于回收站的Inode</strong></td>
</tr>
<tr>
<td style="text-align:center">attr</td>
<td style="text-align:center">name文件的属性</td>
</tr>
<tr>
<td style="text-align:center">pattr</td>
<td style="text-align:center">parent的属性</td>
</tr>
<tr>
<td style="text-align:center">opened</td>
<td style="text-align:center">在unlink阶段，name文件是否打开<br>如果是打开状态，在删除真实存储数据时，会将当前文件的inode放入一个删除队列中</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>获取parent目录下name的属性（字节数组buf）</p>
</li>
<li><p>如果<strong>buf是空</strong>且<strong>配置的挂载目录中存在:</strong>则需要去调用resolveCase方法查询name的属性</p>
</li>
<li><p>解析buf中的属性</p>
</li>
<li><p>name的文件属性不能为文件夹</p>
</li>
<li><p>使用keys（keys中存储删除相关的inodeKey）完成Redis在unlink时的事务一致性</p>
</li>
<li><p>调用<strong>checkTrash方法</strong>判断<strong>parent是否属于回收站的Inode</strong>或当前<strong>挂载配置中是否配置回收站</strong></p>
<blockquote>
<p>详解见<a href="#redisMeta.checkTrash">校验Inode是否在回收站中</a></p>
</blockquote>
<p><strong>以下进入JuiceFS Unlink Redis的事务</strong></p>
<hr>
<p>获取parent和inode的文件属性</p>
</li>
<li><p>如果<strong>parent文件属性不存在</strong>或<strong>parnet文件类型不是文件夹</strong>，则返回</p>
</li>
<li><p>inode文件属性存在</p>
<ul>
<li>解析inode的文件属性</li>
<li>当前操作的用户id为0 、parent的用户是当前用户、inode的用户是当前用户。只要满足一个都可以进行删除操作</li>
<li>trash=0，删除回收站的文件<ul>
<li>将attr的硬链接个数-1</li>
<li><strong>inode类型为文件</strong> 且 <strong>inode硬链接个数为0</strong> 则判断当前inode文件是否是打开，用opened字段记录</li>
</ul>
</li>
<li>attr.Nlink = 1，inode文件硬链接个数为1<ul>
<li>就将inode的attr中的parent设置为trash</li>
</ul>
</li>
</ul>
</li>
<li><p>inode文件属性不存在</p>
<ul>
<li>trash设置为0</li>
</ul>
</li>
<li><p>再次获取name的inode和attr，如果不存在则返回</p>
</li>
<li><p>校验再次获取的文件类型、inode和第一次获取的是否一样，不一样则返回</p>
<ul>
<li>防止误删，在快到进行Redis删除事务时，前一个调用已经将name删除了，但是又创建了同一个名称的name文件</li>
</ul>
</li>
</ul>
<p><strong>以下是进入JuiceFS UnLink重试命令</strong></p>
<hr>
<ol>
<li><p><strong>inode还有硬链接</strong> 且 <strong>不在回收站中</strong> </p>
<p>删除parent目录中的name文件 -&gt; del [d&amp;parent,name]<br>更新parent目录的attr -&gt; set [i&amp;parent,pattr]<br>更新inode文件的attr -&gt; set [i&amp;inode,attr]<br>添加inode文件到trash目录中 -&gt; hset [d&amp;trash,parent-inode-name,buf]</p>
</li>
<li><p><strong>inode还有硬链接</strong> 且 <strong>在回收站中</strong></p>
<ol>
<li><strong>Q：</strong> 为什么在回收站中，还有硬链接？<br><strong>A：</strong>因为无论删除非回收站的硬链接中的哪一个文件，真正的Inode元数据和实际内容Block只有一份</li>
</ol>
<p>删除parent目录中的name文件 -&gt; del [d&amp;parent,name]<br>更新parent目录的attr -&gt; set [i&amp;parent,pattr]<br>更新inode文件的attr -&gt; set [i&amp;inode,attr]</p>
</li>
<li><p>inode在回收站中（<strong>无硬链接个数</strong>）</p>
<ol>
<li><p><strong>Q：</strong>按道理来说无论文件在不在回收站，Nlink默认都会有1，怎么也不会进入这个分支<br><strong>A：</strong>因为在上面判断文件是否在回收站时，已经<strong>将Inode文件的Nlink数量-1</strong>了，元数据引擎中Inode的attr.Nlink还是1，但在本方法中的attr.Nlink已经为0</p>
</li>
<li><p>类型为文件 且 文件已经打开</p>
<p>当前删除的文件正在打开无法删除，等待它关闭释放后，我们去删除此inode</p>
<p>更新inode文件的attr -&gt; set [i&amp;inode,attr]<br>添加inode到当前session中 -&gt; zadd [session$sid,inode]<br>删除额外属性 -&gt; del [x&amp;inode]</p>
</li>
<li><p>类型为文件 且 文件未打开</p>
<p>添加当前删除操作到delfiles中 -&gt; zadd [delfiles,timestamp,inode]<br>删除文件属性 -&gt; del [i&amp;inode]|<br>更新使用空间 -&gt; incr [useSpace, -attr.length]<br>减少inode数量 -&gt; decr [totalInodes]<br>删除额外属性 -&gt; del [x&amp;inode]</p>
</li>
<li><p>类型为软链接</p>
<p>删除软链接 -&gt; del [s&amp;inode]<br>删除软链接inode -&gt; del [i&amp;inode]<br>更新使用空间 -&gt; incr [useSpace, 0]<br>减少inode数量 -&gt; decr [totalInodes]<br>删除额外属性 -&gt; del [x&amp;inode]</p>
</li>
<li><p>类型为其它</p>
<p>删除当前其它的inode -&gt; del [i&amp;inode]<br>更新使用空间 -&gt; incr [useSpace, 0]<br>减少inode数量 -&gt; decr [totalInodes]<br>删除额外属性 -&gt; del [x&amp;inode]</p>
</li>
</ol>
</li>
</ol>
<hr>
<p><strong>以下是删除文件Block</strong></p>
<p>满足 <strong>删除元数据错误码为nil</strong> 且 <strong>类型是文件</strong> 且 <strong>文件硬链接个数为0</strong> 就可以删除文件的Block</p>
<blockquote>
<p>见<a href="#baseMeta.fileDeleted">删除文件Block</a></p>
</blockquote>
<pre class=" language-lang-go"><code class="language-lang-go">func (r *redisMeta) doUnlink(ctx Context, parent Ino, name string) syscall.Errno {
    // 获取name的inode和attr
    buf, err := r.rdb.HGet(ctx, r.entryKey(parent), name).Bytes()
    // 如果获取的inode和attr为空且挂载目录中有:，则去做一次doReaddir
    if err == redis.Nil && r.conf.CaseInsensi {
        if e := r.resolveCase(ctx, parent, name); e != nil {
            name = string(e.Name)
            buf = r.packEntry(e.Attr.Typ, e.Inode)
            err = nil
        }
    }
    if err != nil {
        return errno(err)
    }
    // 解析出name文件的类型和inode
    _type, inode := r.parseEntry(buf)
    // 无法删除类型是文件夹的东西
    if _type == TypeDirectory {
        return syscall.EPERM
    }
    keys := []string{r.entryKey(parent), r.inodeKey(parent), r.inodeKey(inode)}
    var trash Ino
    // 校验是否是回收站的删除
    // 如果实在回收站中st=0;不在回收站中st=回收站文件父目录inode
    if st := r.checkTrash(parent, &trash); st != 0 {
        return st
    }
    if trash > 0 {
        logger.Infof("redisMeta doUnlink trash:%d", trash)
        keys = append(keys, r.entryKey(trash))
    } else {
        defer func() { r.of.InvalidateChunk(inode, 0xFFFFFFFE) }()
    }
    var opened bool
    var attr Attr
    err = r.txn(ctx, func(tx *redis.Tx) error {
        // 获取parent和inode的属性
        rs, _ := tx.MGet(ctx, r.inodeKey(parent), r.inodeKey(inode)).Result()
        // parent的属性不存在则返回
        if rs[0] == nil {
            return redis.Nil
        }
        var pattr Attr
        // 解析parent的属性
        r.parseAttr([]byte(rs[0].(string)), &pattr)
        // parent的Typ不为目录则返回
        if pattr.Typ != TypeDirectory {
            return syscall.ENOTDIR
        }
        now := time.Now()
        pattr.Mtime = now.Unix()
        pattr.Mtimensec = uint32(now.Nanosecond())
        pattr.Ctime = now.Unix()
        pattr.Ctimensec = uint32(now.Nanosecond())
        attr = Attr{}
        opened = false
        if rs[1] != nil {
            // 解析inode的文件属性
            r.parseAttr([]byte(rs[1].(string)), &attr)
            // 只要一个不满足就可以删除
            if ctx.Uid() != 0 && pattr.Mode&01000 != 0 && ctx.Uid() != pattr.Uid && ctx.Uid() != attr.Uid {
                return syscall.EACCES
            }
            attr.Ctime = now.Unix()
            attr.Ctimensec = uint32(now.Nanosecond())
            if trash == 0 {
                // 删除回收站的垃圾文件
                logger.Infof("redisMeta doUnlink name[%s] inode[%d] are in the grabage[%d]", name, inode, parent)
                attr.Nlink--
                if _type == TypeFile && attr.Nlink == 0 {
                    opened = r.of.IsOpen(inode)
                }
            } else if attr.Nlink == 1 { // don't change parent if it has hard links
                // 如果有硬链接，就无法将当前Inode的父设置为trash
// 无论删除硬链接中的哪一个另外的都会完好无损，正本只有一个「换句话说，存储一份数据，用Nlink维护硬链接个数」
                attr.Parent = trash
            }
        } else {
            // 不存在inode的属性
            logger.Warnf("no attribute for inode %d (%d, %s)", inode, parent, name)
            trash = 0
        }
        // 在一次校验
        buf, err := tx.HGet(ctx, r.entryKey(parent), name).Bytes()
        // 不存在则返回
        if err != nil {
            return err
        }
        // 校验保存在的的d*和i*中的Inode和Typ是否一样
        _type2, inode2 := r.parseEntry(buf)
        if _type2 != _type || inode2 != inode {
            return syscall.EAGAIN
        }

        _, err = tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {
            // 删除父目录中的name文件
            pipe.HDel(ctx, r.entryKey(parent), name)
            // 重新设置parent的属性
            pipe.Set(ctx, r.inodeKey(parent), r.marshal(&pattr), 0)
            if attr.Nlink > 0 {
                // 有硬链接只更新属性
                pipe.Set(ctx, r.inodeKey(inode), r.marshal(&attr), 0)
                if trash > 0 {
                    // 当前inode不在回收站的文件，需要放入回收站
                    pipe.HSet(ctx, r.entryKey(trash), fmt.Sprintf("%d-%d-%s", parent, inode, name), buf)
                }
            } else {
                // 回收站中的文件
                switch _type {
                case TypeFile:
                    if opened {
                        // 当前文件出于开启状态
                        // 更新inode的属性，此时还不能将其i&inode删除
                        // 等当前文件关闭后，会真正删除inode文件的元数据，那时候会去元数据引擎中寻找元数据
                        pipe.Set(ctx, r.inodeKey(inode), r.marshal(&attr), 0)
// 将inode添加入session$sid中，和当前session绑定。为以后关闭当前session时可以做一些未来得及清除的工作
                        pipe.SAdd(ctx, r.sustained(r.sid), strconv.Itoa(int(inode)))
                    } else {
                        // 将文件添加入delfiles中
                        pipe.ZAdd(ctx, delfiles, &redis.Z{Score: float64(now.Unix()), Member: r.toDelete(inode, attr.Length)})
                        // 删除文件的属性i*
                        pipe.Del(ctx, r.inodeKey(inode))
                        // 更新用户的使用空间
                        pipe.IncrBy(ctx, usedSpace, -align4K(attr.Length))
                        // 减少Inode数量
                        pipe.Decr(ctx, totalInodes)
                    }
                case TypeSymlink:
                    // 是一个软链接，直接删除软连接s*，软链接可以链接文件夹，所以会执行default中的内容
                    pipe.Del(ctx, r.symKey(inode))
                    fallthrough
                default:
                    // 删除的是文件夹/软链接
                    pipe.Del(ctx, r.inodeKey(inode))
                    pipe.IncrBy(ctx, usedSpace, -align4K(0))
                    pipe.Decr(ctx, totalInodes)
                } // 删除文件的Xattr属性
                pipe.Del(ctx, r.xattrKey(inode))
            }
            return nil
        })

        return err
    }, keys...)
    // (删除元数据成功 && 类型是文件 && 硬链接个数为0) 以上都满足即可删除真实数据
    if err == nil && _type == TypeFile && attr.Nlink == 0 {
        r.fileDeleted(opened, inode, attr.Length)
    }
    return errno(err)
}
</code></pre>
<h3 id="Mknod"><a href="#Mknod" class="headerlink" title="Mknod"></a>Mknod</h3><h4 id="baseMeta-Mknod"><a href="#baseMeta-Mknod" class="headerlink" title="baseMeta.Mknod"></a>baseMeta.Mknod</h4><ul>
<li>无法在回收站中创建文件/文件夹</li>
<li>无法在挂载点下创建与回收站同名的文件/文件夹</li>
<li>当前挂载点只读权限时，无法执行创建</li>
</ul>
<pre class=" language-lang-go"><code class="language-lang-go">func (m *baseMeta) Mknod(ctx Context, parent Ino, name string, _type uint8, mode, cumask uint16, rdev uint32, path string, inode *Ino, attr *Attr) syscall.Errno {
    logger.Infof("baseMeta Mknod parent:%d name:%s type:%s mode:%d cumask:%d rdev:%d path:%s", parent, name, m.getFileType(_type), mode, cumask, rdev, path)
    // 无法在回收站中创建文件/文件夹
    if isTrash(parent) {
        return syscall.EPERM
    }
    // 无法在挂载点下创建与回收站同名的文件/文件夹
    if parent == 1 && name == TrashName {
        return syscall.EPERM
    }
    // 当前挂载点是只读权限，无法执行创建
    if m.conf.ReadOnly {
        return syscall.EROFS
    }

    defer timeit(time.Now())
    if m.checkQuota(4<<10, 1) {
        return syscall.ENOSPC
    }
    return m.en.doMknod(ctx, m.checkRoot(parent), name, _type, mode, cumask, rdev, path, inode, attr)
}
</code></pre>
<h4 id="redisMeta-doMknod"><a href="#redisMeta-doMknod" class="headerlink" title="redisMeta.doMknod"></a>redisMeta.doMknod</h4><ul>
<li>父目录Inode为回收站<ul>
<li><strong>Q：</strong>baseMeta.Mknod中明确不能在回收站中创建文件夹和文件，为什么这里需要加这个判断？<br><strong>A：</strong>其它方法会直接调用baseMeta.doMknod，用来创建回收站时间归档文件夹，用于对不同时间段放入回收站的文件/文件夹进行归档</li>
<li>对nextTrash进行递增，用默认<strong>TrashInode+增量</strong>可获得日期归档文件夹的inode</li>
</ul>
</li>
<li>父目录Inode不为回收站<ul>
<li>正常获取下一个Inode</li>
</ul>
</li>
<li>创建的是文件夹<ul>
<li>Nlink=2，文件夹的默认硬链接个数</li>
</ul>
</li>
<li>创建的是文件<ul>
<li>Nlink=1，文件的默认硬链接个数</li>
</ul>
</li>
</ul>
<p><strong>以下进入JuiceFS doMknod Redis的事务</strong></p>
<hr>
<ul>
<li>获取parent的属性并解析，parent属性中Typ不是文件夹则返回</li>
<li>更新parent属性的参数</li>
</ul>
<p><strong>以下是进入JuiceFS doMknod重试命令</strong></p>
<hr>
<ol>
<li><p>创建的是软链接</p>
<p>将name添加到parent的文件夹中 -&gt; hset[d&amp;parent,name,typ ino]<br>更新parent的属性 -&gt; set[i&amp;parent,pattr]<br>添加ino属性 -&gt; set[i&amp;ino,attr]<br>更新使用空间 -&gt; incrBy[usedSpace,4KB]<br>增加inode数量 -&gt; incr[totalInodes]</p>
</li>
<li><p>创建的是其它（除软链接）</p>
<p>将name添加到parent的文件夹中 -&gt; hset[d&amp;parent,name,typ ino]<br>更新parent的属性 -&gt; set[i&amp;parent,pattr]<br>添加ino属性 -&gt; set[i&amp;ino,attr]<br>添加软链接 -&gt; set[s&amp;ino,path]<br>更新使用空间 -&gt; incrBy[usedSpace,4KB]<br>增加inode数量 -&gt; incr[totalInodes]</p>
</li>
</ol>
<pre class=" language-lang-go"><code class="language-lang-go">func (r *redisMeta) doMknod(ctx Context, parent Ino, name string, _type uint8, mode, cumask uint16, rdev uint32, path string, inode *Ino, attr *Attr) syscall.Errno {
    var ino Ino
    var err error
    if parent == TrashInode {
        // parent是回收站，则创建一个回收站的inode
        // baseMeta.Mknod中不允许在回收站中创建文件，是对于用户的手动创建而言。
        // 这里生成的inode时用于存放不同时间段被放入回收站的文件/文件夹的目录，是通过其他方法直接调用此处doMknod方法
        var next int64
        next, err = r.incrCounter("nextTrash", 1)
        ino = TrashInode + Ino(next)
    } else {
        // 正常的文件/文件夹
        ino, err = r.nextInode()
    }
    if err != nil {
        return errno(err)
    }
    if attr == nil {
        attr = &Attr{}
    }
    attr.Typ = _type
    attr.Mode = mode & ^cumask
    attr.Uid = ctx.Uid()
    attr.Gid = ctx.Gid()
    if _type == TypeDirectory {
        // 文件夹默认的Nlink包含自身和自己与父目录
        attr.Nlink = 2
        // 文件夹默认大小 4KB
        attr.Length = 4 << 10
    } else {
        // 文件默认的Nlink只是自身
        attr.Nlink = 1
        if _type == TypeSymlink {
            // 软链接
            attr.Length = uint64(len(path))
        } else {
            // 其它
            attr.Length = 0
            attr.Rdev = rdev
        }
    }
    attr.Parent = parent
    attr.Full = true
    if inode != nil {
        // 手动赋值ino
        *inode = ino
    }

    return errno(r.txn(ctx, func(tx *redis.Tx) error {
        var pattr Attr
        // 获取parent的属性
        a, err := tx.Get(ctx, r.inodeKey(parent)).Bytes()
        if err != nil {
            return err
        }
        // 解析parent的属性
        r.parseAttr(a, &pattr)
        // parent的type不是文件夹 返回
        if pattr.Typ != TypeDirectory {
            return syscall.ENOTDIR
        }
        // 获取name的属性
        buf, err := tx.HGet(ctx, r.entryKey(parent), name).Bytes()
        // 获取的属性err 存在则返回
        if err != nil && err != redis.Nil {
            return err
        }
        var foundIno Ino
        var foundType uint8
        if err == nil {
            // 解析buf中的Inode和Typ
            foundType, foundIno = r.parseEntry(buf)
        } else if r.conf.CaseInsensi { // err == redis.Nil
            if entry := r.resolveCase(ctx, parent, name); entry != nil {
                foundType, foundIno = entry.Attr.Typ, entry.Inode
            }
        }
        if foundIno != 0 {
            if _type == TypeFile || _type == TypeDirectory { // file for create, directory for subTrash
                a, err = tx.Get(ctx, r.inodeKey(foundIno)).Bytes()
                if err == nil {
                    r.parseAttr(a, attr)
                } else if err == redis.Nil {
                    *attr = Attr{Typ: foundType, Parent: parent} // corrupt entry
                } else {
                    return err
                }
                if inode != nil {
                    *inode = foundIno
                }
            }
            return syscall.EEXIST
        }

        now := time.Now()
        if _type == TypeDirectory {
            pattr.Nlink++
        }
        pattr.Mtime = now.Unix()
        pattr.Mtimensec = uint32(now.Nanosecond())
        pattr.Ctime = now.Unix()
        pattr.Ctimensec = uint32(now.Nanosecond())
        attr.Atime = now.Unix()
        attr.Atimensec = uint32(now.Nanosecond())
        attr.Mtime = now.Unix()
        attr.Mtimensec = uint32(now.Nanosecond())
        attr.Ctime = now.Unix()
        attr.Ctimensec = uint32(now.Nanosecond())
        if pattr.Mode&02000 != 0 || ctx.Value(CtxKey("behavior")) == "Hadoop" || runtime.GOOS == "darwin" {
            attr.Gid = pattr.Gid
            if _type == TypeDirectory && runtime.GOOS == "linux" {
                attr.Mode |= pattr.Mode & 02000
            }
        }

        _, err = tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {
            // 将name添加入parent文件夹中 d&parent
            pipe.HSet(ctx, r.entryKey(parent), name, r.packEntry(_type, ino))
            // 更新parent文件夹的属性 i&parent
            pipe.Set(ctx, r.inodeKey(parent), r.marshal(&pattr), 0)
            // 添加ino的属性 i&ino
            pipe.Set(ctx, r.inodeKey(ino), r.marshal(attr), 0)
            if _type == TypeSymlink {
                // 软链接，将软链接和源文件/文件夹inode绑定 s&ino
                pipe.Set(ctx, r.symKey(ino), path, 0)
            }
            // 增加使用空间
            pipe.IncrBy(ctx, usedSpace, align4K(0))
            // 增加inode数量
            pipe.Incr(ctx, totalInodes)
            return nil
        })
        return err
    }, r.inodeKey(parent), r.entryKey(parent)))
}
</code></pre>
<h3 id="Rmdir"><a href="#Rmdir" class="headerlink" title="Rmdir"></a>Rmdir</h3><h4 id="baseMeta-Rmdir"><a href="#baseMeta-Rmdir" class="headerlink" title="baseMeta.Rmdir"></a>baseMeta.Rmdir</h4><ul>
<li>无法删除 . 或 .. </li>
<li><strong>无法删除回收站</strong> 或 <strong>无法删除回收站中用于归档的文件夹</strong> 或 <strong>非sudo用户无法删除所有回收站中的内容</strong></li>
<li>挂载点只读权限无法执行删除文件夹操作</li>
</ul>
<pre class=" language-lang-go"><code class="language-lang-go">func (m *baseMeta) Rmdir(ctx Context, parent Ino, name string) syscall.Errno {
    // 无法删除.
    if name == "." {
        return syscall.EINVAL
    }
    // 无法删除..
    if name == ".." {
        return syscall.ENOTEMPTY
    }
    // 无法删除回收站、无法删除回收站中用于归档的文件夹、非sudo用户无法删除所有归档文件夹中的垃圾文件
    if parent == 1 && name == TrashName || parent == TrashInode || isTrash(parent) && ctx.Uid() != 0 {
        return syscall.EPERM
    }
    // 挂载点只读无法执行删除文件夹操作
    if m.conf.ReadOnly {
        return syscall.EROFS
    }

    defer timeit(time.Now())
    return m.en.doRmdir(ctx, m.checkRoot(parent), name)
}
</code></pre>
<h4 id="redisMeta-doRmdir"><a href="#redisMeta-doRmdir" class="headerlink" title="redisMeta.doRmdir"></a>redisMeta.doRmdir</h4><ul>
<li>获取name的inode和Typ并解析</li>
<li>name的Typ不是文件夹则返回</li>
<li>查看parent是否为回收站的文件夹，不是则将trash设置为当前时间格式的回收站归档文件夹的inode</li>
<li>将doRmdir涉及到的所有key放入keys数组中用于Redis watch</li>
</ul>
<p><strong>以下进入JuiceFS doRmdir Redis的事务</strong></p>
<hr>
<ul>
<li>获取parent和inode的属性，parent属性为空则返回</li>
<li>解析parent的属性，若parent的Typ不为文件夹则返回</li>
<li>更新parent的属性，主要是将Nlink个数减一</li>
<li>获取name文件夹的inode和Typ并解析</li>
<li>如果name文件夹的Typ不为文件夹则返回</li>
<li>查看name文件夹中的文件数量，大于0则返回（d&amp;inode），无法删除不为空的文件夹</li>
<li>解析出attr不为空<ul>
<li><strong>sudo用户</strong> 或 <strong>父目录的创建者</strong> 或 <strong>当前目录的创建者</strong> 满足其一就可以对name目录进行删除操作</li>
<li>trash &gt; 0时，说明name文件夹需放入回收站中，attr的parent设置为trash</li>
</ul>
</li>
<li>解析出attr为空<ul>
<li>trash = 0，attr为空说明该文件不存在，无法将其放入回收站中</li>
</ul>
</li>
</ul>
<p><strong>以下是进入JuiceFS doRmdir重试命令</strong></p>
<hr>
<ul>
<li><p>非回收站文件夹</p>
<p>从parent目录中删除name文件夹 -&gt; hdel [d&amp;parent,name]<br>更新parent目录属性 -&gt; set [i&amp;parent,pattr]<br>更新name文件夹属性 -&gt; set [i&amp;inode,attr]<br>将name添加入trash目录下 -&gt; hset [d&amp;trash,parent-inode-name]</p>
</li>
<li><p>回收站文件夹</p>
<p>从parent目录中删除name文件夹 -&gt; hdel [d&amp;parent,name]<br>更新parent目录属性 -&gt; set [i&amp;parent,pattr]<br>删除inode文件夹 -&gt; del [i&amp;inode]<br>删除inode额外属性 -&gt; del [x&amp;inode]<br>减少用量 -&gt; incrby [4KB]<br>减少inode数量 -&gt; decr [totalInodes]</p>
</li>
</ul>
<pre class=" language-lang-go"><code class="language-lang-go">func (r *redisMeta) doRmdir(ctx Context, parent Ino, name string) syscall.Errno {
    // 获取name的inode和Typ
    buf, err := r.rdb.HGet(ctx, r.entryKey(parent), name).Bytes()
    if err == redis.Nil && r.conf.CaseInsensi {
        // 特殊情况再去获取
        if e := r.resolveCase(ctx, parent, name); e != nil {
            name = string(e.Name)
            buf = r.packEntry(e.Attr.Typ, e.Inode)
            err = nil
        }
    }
    if err != nil {
        return errno(err)
    }
    // 解析出name的inode和Typ
    typ, inode := r.parseEntry(buf)
    // typ不为dir则返回
    if typ != TypeDirectory {
        return syscall.ENOTDIR
    }
    // Rmdir涉及到的所有key
    keys := []string{r.inodeKey(parent), r.entryKey(parent), r.inodeKey(inode), r.entryKey(inode)}
    var trash Ino
    // 校验parent是否为回收站的inode
    if st := r.checkTrash(parent, &trash); st != 0 {
        return st
    }
    if trash > 0 {
        // 不是回收站的inode，需要对trash的归档目录进行更新属性
        keys = append(keys, r.entryKey(trash))
    }
    return errno(r.txn(ctx, func(tx *redis.Tx) error {
        // 获取parent和inode属性
        rs, _ := tx.MGet(ctx, r.inodeKey(parent), r.inodeKey(inode)).Result()
        // parent属性不能为空
        if rs[0] == nil {
            return redis.Nil
        }
        var pattr, attr Attr
        // 解析parent的属性
        r.parseAttr([]byte(rs[0].(string)), &pattr)
        // pattr属性不为文件夹则返回
        if pattr.Typ != TypeDirectory {
            return syscall.ENOTDIR
        }
        // 更新pattr的各个属性
        now := time.Now()
        pattr.Nlink--
        pattr.Mtime = now.Unix()
        pattr.Mtimensec = uint32(now.Nanosecond())
        pattr.Ctime = now.Unix()
        pattr.Ctimensec = uint32(now.Nanosecond())
        // 获取name文件夹的inode和Typ
        buf, err := tx.HGet(ctx, r.entryKey(parent), name).Bytes()
        if err != nil {
            return err
        }
        // 解析name文件夹
        typ, inode = r.parseEntry(buf)
        // name的Typ不为文件夹则返回
        if typ != TypeDirectory {
            return syscall.ENOTDIR
        }
        // 查看inode的文件夹中的文件数量
        cnt, err := tx.HLen(ctx, r.entryKey(inode)).Result()
        if err != nil {
            return err
        }
        // 删除文件夹时，文件数量必须为0
        if cnt > 0 {
            return syscall.ENOTEMPTY
        }
        if rs[1] != nil {
            // 解析name文件夹的属性
            r.parseAttr([]byte(rs[1].(string)), &attr)
            // sudo用户 或 是父目录的创建者 或 是当前目录的创建者 满足其一都可以执行删除文件夹操作
            if ctx.Uid() != 0 && pattr.Mode&01000 != 0 && ctx.Uid() != pattr.Uid && ctx.Uid() != attr.Uid {
                return syscall.EACCES
            }
            if trash > 0 {
                // 不是回收站（需要放入回收站中），需要将inode文件夹放入回收站归档文件夹中，需要关联当前文件和归档文件夹的关系
                attr.Ctime = now.Unix()
                attr.Ctimensec = uint32(now.Nanosecond())
                attr.Parent = trash
            }
        } else {
            // 没有此inode的属性
            logger.Warnf("no attribute for inode %d (%d, %s)", inode, parent, name)
            trash = 0
        }

        _, err = tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {
            // 从原父目录中删除name文件夹
            pipe.HDel(ctx, r.entryKey(parent), name)
            // 更新原父目录的属性
            pipe.Set(ctx, r.inodeKey(parent), r.marshal(&pattr), 0)
            if trash > 0 {
                // 不在回收站中（需要放入回收站中）
                // 更新当前inode的属性
                pipe.Set(ctx, r.inodeKey(inode), r.marshal(&attr), 0)
                // 将inode文件夹添加入回收站的归档文件夹中 parent-inode-name的格式作为hash的第二个key
                pipe.HSet(ctx, r.entryKey(trash), fmt.Sprintf("%d-%d-%s", parent, inode, name), buf)
            } else {
                // 回收站的文件夹
                // 删除inode
                pipe.Del(ctx, r.inodeKey(inode))
                // 删除inode的额外属性
                pipe.Del(ctx, r.xattrKey(inode))
                // 减少用量
                pipe.IncrBy(ctx, usedSpace, -align4K(0))
                // 减少inode数量
                pipe.Decr(ctx, totalInodes)
            }
            return nil
        })
        return err
    }, keys...))
}
</code></pre>
<h3 id="Rename"><a href="#Rename" class="headerlink" title="Rename"></a>Rename</h3><h4 id="baseMeta-Rename"><a href="#baseMeta-Rename" class="headerlink" title="baseMeta.Rename"></a>baseMeta.Rename</h4><p>编辑器vim、各种编辑内容的软件、mv命令都会用到rename</p>
<ul>
<li>无法重命名回收站 且 无法重命名成回收站</li>
<li>除了sudo用户外，无法rename回收站中的文件</li>
<li>挂载点只读权限无法执行rename</li>
</ul>
<pre class=" language-lang-go"><code class="language-lang-go">func (m *baseMeta) Rename(ctx Context, parentSrc Ino, nameSrc string, parentDst Ino, nameDst string, flags uint32, inode *Ino, attr *Attr) syscall.Errno {
    logger.Infof("baseMeta Rename parentSrc:%d nameSrc:%s parentDst:%d nameDst:%s", parentSrc, nameSrc, parentDst, nameDst)
    // 无法重命名回收站 且 无法重命名成回收站
    if parentSrc == 1 && nameSrc == TrashName || parentDst == 1 && nameDst == TrashName {
        return syscall.EPERM
    }
    // 除了sudo用户外，无法rename回收站中的文件
    if isTrash(parentDst) || isTrash(parentSrc) && ctx.Uid() != 0 {
        return syscall.EPERM
    }
    // 挂载点只读权限无法执行Rename
    if m.conf.ReadOnly {
        return syscall.EROFS
    }
    switch flags {
    case 0, RenameNoReplace, RenameExchange:
    case RenameWhiteout, RenameNoReplace | RenameWhiteout:
        return syscall.ENOTSUP
    default:
        return syscall.EINVAL
    }

    defer timeit(time.Now())
    return m.en.doRename(ctx, m.checkRoot(parentSrc), nameSrc, m.checkRoot(parentDst), nameDst, flags, inode, attr)
}
</code></pre>
<h4 id="redisMeta-doRename"><a href="#redisMeta-doRename" class="headerlink" title="redisMeta.doRename"></a>redisMeta.doRename</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">变量</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">parentSrc</td>
<td style="text-align:center">源文件/文件夹父目录的inode</td>
</tr>
<tr>
<td style="text-align:center">nameSrc</td>
<td style="text-align:center">源文件/文件夹名称</td>
</tr>
<tr>
<td style="text-align:center">parentDst</td>
<td style="text-align:center">目标文件/文件夹父目录的inode</td>
</tr>
<tr>
<td style="text-align:center">nameDst</td>
<td style="text-align:center">目标文件/文件夹名称</td>
</tr>
<tr>
<td style="text-align:center">typ</td>
<td style="text-align:center">源文件/文件夹类别</td>
</tr>
<tr>
<td style="text-align:center">ino</td>
<td style="text-align:center">源文件/文件夹inode</td>
</tr>
<tr>
<td style="text-align:center">opened</td>
<td style="text-align:center">文件是否打开</td>
</tr>
<tr>
<td style="text-align:center">trash</td>
<td style="text-align:center">目标文件/文件夹存在，放入回收站的父目录inode</td>
</tr>
<tr>
<td style="text-align:center">dino</td>
<td style="text-align:center">目标文件/文件夹inode</td>
</tr>
<tr>
<td style="text-align:center">dtyp</td>
<td style="text-align:center">目标文件/文件夹类别</td>
</tr>
<tr>
<td style="text-align:center">tattr</td>
<td style="text-align:center">目标文件/文件夹属性</td>
</tr>
<tr>
<td style="text-align:center">sattr、dattr、iattr</td>
<td style="text-align:center">【事务中】源父目录属性、目标目录属性、源文件/文件夹属性</td>
</tr>
<tr>
<td style="text-align:center">tattr</td>
<td style="text-align:center">【事务中】目标文件/文件夹属性</td>
</tr>
<tr>
<td style="text-align:center">typ1</td>
<td style="text-align:center">【事务中】源文件/文件夹类别</td>
</tr>
<tr>
<td style="text-align:center">ino1</td>
<td style="text-align:center">【事务中】源文件/文件夹inode</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>获取nameSrc的Inode和Typ并解析</li>
<li>如果自己Rename自己则返回</li>
<li>获取nameDst的Inode和Typ并解析</li>
<li>所有涉及的key都放入keys中</li>
<li>如果nameDst存在（需要对nameDst是否放入回收站进行判断）<ul>
<li>判断其是否已经是回收站中的文件，如果是则将trash放入keys中</li>
<li>将nameDst的inode i&amp;inode添加入keys中</li>
<li>如果nameDst是文件夹则将其d&amp;inode添加入keys中</li>
</ul>
</li>
</ul>
<p><strong>以下进入JuiceFS doRename Redis的事务</strong></p>
<hr>
<ul>
<li>获取parentSrc、parentDst、ino的属性，其中一个为null则返回</li>
<li>解析parentSrc和parentDst的属性并判断其是否是文件夹，不为文件夹则返回</li>
<li>获取nameDst的Typ和Inode并解析</li>
<li>如果nameDst的dino和dino1不一样或者nameDst的dTyp1和dTyp不一样则重试</li>
<li>获取nameDst的属性</li>
<li>nameDst回收站中文件<ul>
<li>将其硬链接个数-1，且判断其是否打开状态，用opened记录</li>
</ul>
</li>
<li>nameDst不在回收站中<ul>
<li>将nameDst属性中的parent设置为trash</li>
</ul>
</li>
</ul>
<pre class=" language-lang-go"><code class="language-lang-go">func (r *redisMeta) doRename(ctx Context, parentSrc Ino, nameSrc string, parentDst Ino, nameDst string, flags uint32, inode *Ino, attr *Attr) syscall.Errno {
    logger.Infof("redisMeta doRename parentSrc:%d srcName:%s parentDst:%d nameDst:%s", parentSrc, nameSrc, parentDst, nameDst)
    exchange := flags == RenameExchange
    // 获取nameSrc的inode和Typ
    buf, err := r.rdb.HGet(ctx, r.entryKey(parentSrc), nameSrc).Bytes()
    if err == redis.Nil && r.conf.CaseInsensi {
        if e := r.resolveCase(ctx, parentSrc, nameSrc); e != nil {
            nameSrc = string(e.Name)
            buf = r.packEntry(e.Attr.Typ, e.Inode)
            err = nil
        }
    }
    if err != nil {
        return errno(err)
    }
    // 解析nameSrc的inode和Typ
    typ, ino := r.parseEntry(buf)
    // 判断是否是自己rename自己
    if parentSrc == parentDst && nameSrc == nameDst {
        if inode != nil {
            *inode = ino
        }
        return 0
    }
    // 获取nameDst的inode和Typ
    buf, err = r.rdb.HGet(ctx, r.entryKey(parentDst), nameDst).Bytes()
    if err == redis.Nil && r.conf.CaseInsensi {
        if e := r.resolveCase(ctx, parentDst, nameDst); e != nil {
            nameDst = string(e.Name)
            buf = r.packEntry(e.Attr.Typ, e.Inode)
            err = nil
        }
    }
    if err != nil && err != redis.Nil {
        return errno(err)
    }
    // 将涉及到的key存放入keys中 源文件父目录d i、源文件i、目标文件父目录d i
    keys := []string{r.entryKey(parentSrc), r.inodeKey(parentSrc), r.inodeKey(ino), r.entryKey(parentDst), r.inodeKey(parentDst)}
    var opened bool
    var trash, dino Ino
    var dtyp uint8
    var tattr Attr
    if err == nil {
        // 目标文件存在时候会走这里
        if st := r.checkTrash(parentDst, &trash); st != 0 {
            return st
        }
        // 添加回收站归档文件夹key
        if trash > 0 {
            keys = append(keys, r.entryKey(trash))
        }
        dtyp, dino = r.parseEntry(buf)
        // 添加已经存在的dino文件进keys
        keys = append(keys, r.inodeKey(dino))
        if dtyp == TypeDirectory {
            keys = append(keys, r.entryKey(dino))
        }
    }
    err = r.txn(ctx, func(tx *redis.Tx) error {
        // 获取parentSrc、parentDst、ino的属性
        rs, _ := tx.MGet(ctx, r.inodeKey(parentSrc), r.inodeKey(parentDst), r.inodeKey(ino)).Result()
        // 只要有一个不存在就返回
        if rs[0] == nil || rs[1] == nil || rs[2] == nil {
            return redis.Nil
        }
        var sattr, dattr, iattr Attr
        // 解析parentSrc、parentDst、ino属性
        r.parseAttr([]byte(rs[0].(string)), &sattr)
        if sattr.Typ != TypeDirectory {
            return syscall.ENOTDIR
        }
        r.parseAttr([]byte(rs[1].(string)), &dattr)
        if dattr.Typ != TypeDirectory {
            return syscall.ENOTDIR
        }
        r.parseAttr([]byte(rs[2].(string)), &iattr)

        // 获取nameDst的Typ和inode
        dbuf, err := tx.HGet(ctx, r.entryKey(parentDst), nameDst).Bytes()
        if err != nil && err != redis.Nil {
            return err
        }
        now := time.Now()
        tattr = Attr{}
        opened = false
        if err == nil {
            // nameDst存在时，会走这里
            // flags = 不能override覆盖
            if flags == RenameNoReplace {
                return syscall.EEXIST
            }
            // 解析出nameDst的Typ和inode
            dtyp1, dino1 := r.parseEntry(dbuf)
            // 解析出的和事务开始前解析的不一样 返回
            if dino1 != dino || dtyp1 != dtyp {
                return syscall.EAGAIN
            }
            // 获取nameDst的属性
            a, err := tx.Get(ctx, r.inodeKey(dino)).Bytes()
            if err == redis.Nil {
                // 没有nameDst的属性
                logger.Warnf("no attribute for inode %d (%d, %s)", dino, parentDst, nameDst)
                trash = 0
            } else if err != nil {
                return err
            }
            // 解析nameDst的属性
            r.parseAttr(a, &tattr)
            tattr.Ctime = now.Unix()
            tattr.Ctimensec = uint32(now.Nanosecond())
            if exchange {
                tattr.Parent = parentSrc
                if dtyp == TypeDirectory && parentSrc != parentDst {
                    dattr.Nlink--
                    sattr.Nlink++
                }
            } else {
                if dtyp == TypeDirectory {
                    cnt, err := tx.HLen(ctx, r.entryKey(dino)).Result()
                    if err != nil {
                        return err
                    }
                    if cnt != 0 {
                        return syscall.ENOTEMPTY
                    }
                    dattr.Nlink--
                    if trash > 0 {
                        tattr.Parent = trash
                    }
                } else {
                    if trash == 0 {
                        // parentDst是回收站的文件夹
                        tattr.Nlink--
                        if dtyp == TypeFile && tattr.Nlink == 0 {
                            opened = r.of.IsOpen(dino)
                        }
                        defer func() { r.of.InvalidateChunk(dino, 0xFFFFFFFE) }()
                    } else if tattr.Nlink == 1 {
                        // 存在的nameDst文件只有一个硬链接，就可以将其父inode设置为trash
                        tattr.Parent = trash
                    }
                }
            }
            if ctx.Uid() != 0 && dattr.Mode&01000 != 0 && ctx.Uid() != dattr.Uid && ctx.Uid() != tattr.Uid {
                return syscall.EACCES
            }
        } else {
            if exchange {
                return syscall.ENOENT
            }
            dino, dtyp = 0, 0
        }
        // 获取namSrc的ino和属性
        buf, err := tx.HGet(ctx, r.entryKey(parentSrc), nameSrc).Bytes()
        if err != nil {
            return err
        }
        // 解析nameSrc的ino和属性
        typ1, ino1 := r.parseEntry(buf)
        if ino1 != ino || typ1 != typ {
            return syscall.EAGAIN
        }
        if ctx.Uid() != 0 && sattr.Mode&01000 != 0 && ctx.Uid() != sattr.Uid && ctx.Uid() != iattr.Uid {
            return syscall.EACCES
        }

        sattr.Mtime = now.Unix()
        sattr.Mtimensec = uint32(now.Nanosecond())
        sattr.Ctime = now.Unix()
        sattr.Ctimensec = uint32(now.Nanosecond())
        dattr.Mtime = now.Unix()
        dattr.Mtimensec = uint32(now.Nanosecond())
        dattr.Ctime = now.Unix()
        dattr.Ctimensec = uint32(now.Nanosecond())
        iattr.Parent = parentDst
        iattr.Ctime = now.Unix()
        iattr.Ctimensec = uint32(now.Nanosecond())
        if typ == TypeDirectory && parentSrc != parentDst {
            sattr.Nlink--
            dattr.Nlink++
        }
        if inode != nil {
            *inode = ino
        }
        if attr != nil {
            *attr = iattr
        }
        _, err = tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {
            if exchange {
                // dbuf, tattr are valid
                pipe.HSet(ctx, r.entryKey(parentSrc), nameSrc, dbuf)
                pipe.Set(ctx, r.inodeKey(dino), r.marshal(&tattr), 0)
            } else {
                // 删除parentSrc中的nameSrc文件/文件夹
                pipe.HDel(ctx, r.entryKey(parentSrc), nameSrc)
                if dino > 0 {
                    // nameDst文件存在
                    if trash > 0 {
                        // 更新nameSrc的属性 将nameSrc添加入回收站中
                        pipe.Set(ctx, r.inodeKey(dino), r.marshal(&tattr), 0)
                        pipe.HSet(ctx, r.entryKey(trash), fmt.Sprintf("%d-%d-%s", parentDst, dino, nameDst), dbuf)
                    } else if dtyp != TypeDirectory && tattr.Nlink > 0 {
                        pipe.Set(ctx, r.inodeKey(dino), r.marshal(&tattr), 0)
                    } else {
                        if dtyp == TypeFile {
                            if opened {
                                pipe.Set(ctx, r.inodeKey(dino), r.marshal(&tattr), 0)
                                pipe.SAdd(ctx, r.sustained(r.sid), strconv.Itoa(int(dino)))
                            } else {
                                pipe.ZAdd(ctx, delfiles, &redis.Z{Score: float64(now.Unix()), Member: r.toDelete(dino, tattr.Length)})
                                pipe.Del(ctx, r.inodeKey(dino))
                                pipe.IncrBy(ctx, usedSpace, -align4K(tattr.Length))
                                pipe.Decr(ctx, totalInodes)
                            }
                        } else {
                            if dtyp == TypeSymlink {
                                pipe.Del(ctx, r.symKey(dino))
                            }
                            pipe.Del(ctx, r.inodeKey(dino))
                            pipe.IncrBy(ctx, usedSpace, -align4K(0))
                            pipe.Decr(ctx, totalInodes)
                        }
                        pipe.Del(ctx, r.xattrKey(dino))
                    }
                }
            }
            if parentDst != parentSrc && !isTrash(parentSrc) {
                // 跨目录 更新parentSrc的属性
                pipe.Set(ctx, r.inodeKey(parentSrc), r.marshal(&sattr), 0)
            }
            pipe.Set(ctx, r.inodeKey(ino), r.marshal(&iattr), 0)
            pipe.HSet(ctx, r.entryKey(parentDst), nameDst, buf)
            pipe.Set(ctx, r.inodeKey(parentDst), r.marshal(&dattr), 0)
            return nil
        })
        return err
    }, keys...)
    if err == nil && !exchange && dino > 0 && dtyp == TypeFile && tattr.Nlink == 0 {
        r.fileDeleted(opened, dino, tattr.Length)
    }
    return errno(err)
}
</code></pre>
<h3 id="redisMeta-checkTrash"><a href="#redisMeta-checkTrash" class="headerlink" title="redisMeta.checkTrash"></a>redisMeta.checkTrash</h3><ul>
<li><strong>没有配置回收站</strong> 或者 <strong>parent是回收站的Inode</strong> trash = 0返回</li>
<li>获取当前的时间格式，作为回收站中的回收目录</li>
<li>查看当前回收目录是否存在，不存在则创建，且更新程序中的m.subTrash.inode和m.subTrash.name字段</li>
</ul>
<pre class=" language-lang-go"><code class="language-lang-go">func (m *baseMeta) checkTrash(parent Ino, trash *Ino) syscall.Errno {
    // 没有配置回收站 或者 parent是回收站中的Inode就返回
    if !m.toTrash(parent) {
        return 0
    }
    // 获取当前时间格式为[2006-01-02-15]
    name := time.Now().UTC().Format("2006-01-02-15")
    m.Lock()
    defer m.Unlock()
    // m.subTrash.name保存着今天回收站的名称
    if name == m.subTrash.name {
        *trash = m.subTrash.inode
        return 0
    }
    m.Unlock()
    // 查看回收站是否存在
    st := m.en.doLookup(Background, TrashInode, name, trash, nil)
    if st == syscall.ENOENT {
        //不存在则创建
        st = m.en.doMknod(Background, TrashInode, name, TypeDirectory, 0555, 0, 0, "", trash, nil)
    }

    m.Lock()
    if st != 0 && st != syscall.EEXIST {
        logger.Warnf("create subTrash %s: %s", name, st)
    } else if *trash <= TrashInode {
        logger.Warnf("invalid trash inode: %d", *trash)
        st = syscall.EBADF
    } else {
        // 创建完赋值
        m.subTrash.inode = *trash
        m.subTrash.name = name
        st = 0
    }
    return st
}
</code></pre>
<h2 id="Tikv存储"><a href="#Tikv存储" class="headerlink" title="Tikv存储"></a>Tikv存储</h2><h3 id="存储格式-1"><a href="#存储格式-1" class="headerlink" title="存储格式"></a>存储格式</h3><pre class=" language-lang-json"><code class="language-lang-json">  Ino iiiiiiii
  Length llllllll
  Indx nnnn
  name ...
  chunkid cccccccc
  session  ssssssss

All keys:
  setting            format
  C...               counter
  AiiiiiiiiI         inode attribute
  AiiiiiiiiD...      dentry
  AiiiiiiiiCnnnn     file chunks
  AiiiiiiiiS         symlink target
  AiiiiiiiiX...      extented attribute
  Diiiiiiiillllllll  delete inodes
  Fiiiiiiii          Flocks
  Piiiiiiii          POSIX locks
  Kccccccccnnnn      slice refs
  SHssssssss         session heartbeat
  SIssssssss         session info
  SSssssssssiiiiiiii sustained inode
</code></pre>
<h3 id="生成Key-1"><a href="#生成Key-1" class="headerlink" title="生成Key"></a>生成Key</h3><pre class=" language-lang-go"><code class="language-lang-go">func (m *kvMeta) inodeKey(inode Ino) []byte {
    return m.fmtKey("A", inode, "I")
}

func (m *kvMeta) entryKey(parent Ino, name string) []byte {
    return m.fmtKey("A", parent, "D", name)
}

func (m *kvMeta) chunkKey(inode Ino, indx uint32) []byte {
    return m.fmtKey("A", inode, "C", indx)
}

func (m *kvMeta) sliceKey(chunkid uint64, size uint32) []byte {
    return m.fmtKey("K", chunkid, size)
}

func (m *kvMeta) symKey(inode Ino) []byte {
    return m.fmtKey("A", inode, "S")
}

func (m *kvMeta) xattrKey(inode Ino, name string) []byte {
    return m.fmtKey("A", inode, "X", name)
}

func (m *kvMeta) flockKey(inode Ino) []byte {
    return m.fmtKey("F", inode)
}

func (m *kvMeta) plockKey(inode Ino) []byte {
    return m.fmtKey("P", inode)
}

func (m *kvMeta) sessionKey(sid uint64) []byte {
    return m.fmtKey("SH", sid)
}

func (m *kvMeta) parseSid(key string) uint64 {
    buf := []byte(key[2:]) // "SH"
    if len(buf) != 8 {
        panic("invalid sid value")
    }
    return binary.BigEndian.Uint64(buf)
}

func (m *kvMeta) sessionInfoKey(sid uint64) []byte {
    return m.fmtKey("SI", sid)
}

func (m *kvMeta) sustainedKey(sid uint64, inode Ino) []byte {
    return m.fmtKey("SS", sid, inode)
}

func (m *kvMeta) encodeInode(ino Ino, buf []byte) {
    binary.LittleEndian.PutUint64(buf, uint64(ino))
}

func (m *kvMeta) decodeInode(buf []byte) Ino {
    return Ino(binary.LittleEndian.Uint64(buf))
}

func (m *kvMeta) delfileKey(inode Ino, length uint64) []byte {
    return m.fmtKey("D", inode, length)
}

func (m *kvMeta) counterKey(key string) []byte {
    return m.fmtKey("C", key)
}
</code></pre>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">TangRunZe</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://t-trz879.github.io/2022/07/10/JuiceFS%E5%85%83%E6%95%B0%E6%8D%AE/">https://t-trz879.github.io/2022/07/10/JuiceFS%E5%85%83%E6%95%B0%E6%8D%AE/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">TangRunZe</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/metadata%E5%AD%98%E5%82%A8/">
                                    <span class="chip bg-color">metadata存储</span>
                                </a>
                            
                                <a href="/tags/Redis/">
                                    <span class="chip bg-color">Redis</span>
                                </a>
                            
                                <a href="/tags/Tikv/">
                                    <span class="chip bg-color">Tikv</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'Ki1wxfit4Lmi598jiXynUesI-gzGzoHsz',
        appKey: 'FeYJnjDoDGC8Y4oP3ru6PN6C',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: 'just go go'
    });
</script>

<!--酷Q推送-->


    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/07/10/%E4%BD%BF%E7%94%A8Jna%E8%B0%83%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89C%E6%96%B9%E6%B3%95/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/7.jpg" class="responsive-img" alt="MacOSX使用Jna调用自定义C方法">
                        
                        <span class="card-title">MacOSX使用Jna调用自定义C方法</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-07-10
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Jna/" class="post-category">
                                    Jna
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%B7%A8%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8/">
                        <span class="chip bg-color">跨语言调用</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/06/19/%E4%BF%AE%E6%94%B9Homebrew%E6%BA%90/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/10.jpg" class="responsive-img" alt="修改HomeBrew源">
                        
                        <span class="card-title">修改HomeBrew源</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-06-19
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Homebrew/" class="post-category">
                                    Homebrew
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Mac/">
                        <span class="chip bg-color">Mac</span>
                    </a>
                    
                    <a href="/tags/%E4%B8%8B%E8%BD%BD%E6%BA%90/">
                        <span class="chip bg-color">下载源</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFunction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <a href="/about" target="_blank">TangRunZe</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">25.4k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1181062873" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1181062873" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
        
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/sakura.js"><\/script>');
            }
        </script>
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>

</html>
